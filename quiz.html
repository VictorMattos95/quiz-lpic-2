<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Interativo de Linux - Modo Prova</title>
    <style>
        /* CSS Geral (maioria sem alterações) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        #quiz-container {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
            width: 100%;
            max-width: 800px;
        }

        #question-counter {
            font-size: 0.9em;
            color: #555;
            text-align: right;
            margin-bottom: 10px;
        }

        #question {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        #options-container { display: flex; flex-direction: column; gap: 15px; }

        .option {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
            display: flex;
            align-items: center;
        }
        
        .option:hover {
            background-color: #eef2f5;
            border-color: #007bff;
        }

        .option.selected {
            background-color: #d1e7fd;
            border-color: #007bff;
            font-weight: bold;
        }

        #controls {
            margin-top: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
        }

        button:not(:disabled):hover { background-color: #0056b3; }
        
        code {
            font-family: "Courier New", Courier, monospace;
            background-color: #e9e9e9;
            padding: 2px 5px;
            border-radius: 4px;
        }
        
        /* --- ESTILOS PARA O RELATÓRIO FINAL --- */
        #final-report h2, #final-report h3 { text-align: center; color: #333; }
        #final-report p { text-align: center; font-size: 1.2em; margin-bottom: 25px; }
        #report-details { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; font-size: 1.1em; }
        .report-item { background-color: #f9f9f9; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #eee; }
        .report-item strong { display: block; font-size: 1.8em; margin-bottom: 5px; }
        .report-item-acertos strong { color: #155724; }
        .report-item-erros strong { color: #721c24; }
        .report-item-nota strong { color: #0056b3; }

        #detailed-review { margin-top: 40px; border-top: 2px solid #eee; padding-top: 20px; }
        .review-item { margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid #f0f0f0; }
        .review-item h4 { margin: 0 0 10px 0; font-size: 1.1em; }
        .review-item p { font-size: 1em; text-align: left; margin: 5px 0; }
        .resposta-usuario { font-weight: bold; }
        .resposta-errada { color: #721c24; }
        .resposta-certa { color: #155724; }
        .resposta-correta-final { color: #155724; font-weight: bold; }
        .explicacao { font-style: italic; color: #555; margin-top: 10px !important; }

    </style>
</head>
<body>

    <div id="quiz-container">
        </div>

<script>
    const quizData = [
      {
        "id": 1,
        "pergunta": "Qual dos seguintes comandos apaga o conteúdo da partição <code>/dev/sdb3</code>?",
        "opcoes": {
          "A": "<code>rm /dev/sdb3</code>",
          "B": "<code>dd if=/dev/zero of=/dev/sdb3</code>",
          "C": "<code>dd of=/dev/zero if=/dev/sdb3</code>",
          "D": "<code>umount /dev/sdb3</code>"
        },
        "respostaCorreta": "B",
        "explicacao": "O comando 'dd' copia dados. 'if=/dev/zero' especifica a fonte como um fluxo infinito de zeros, e 'of=/dev/sdb3' especifica o destino como a partição. Isso efetivamente sobrescreve toda a partição com zeros, apagando seu conteúdo."
      },
      {
        "id": 2,
        "pergunta": "Qual dos seguintes arquivos será procurado e usado pelo GNU make, a menos que um arquivo diferente seja especificado? (Escolha dois)",
        "opcoes": {
          "A": "<code>configure</code>",
          "B": "<code>config.h.in</code>",
          "C": "<code>makefile</code>",
          "D": "<code>Makefile</code>",
          "E": "<code>Makefile.in</code>"
        },
        "respostaCorreta": ["C", "D"],
        "explicacao": "Por padrão, o GNU make procura por 'Makefile' e 'makefile' (entre outros como 'GNUmakefile') no diretório atual para executar as instruções de compilação."
      },
      {
        "id": 3,
        "pergunta": "Que comando é usado para enviar mensagens para todos os usuários atualmente logados?",
        "tipo": "fill",
        "respostaCorreta": "wall",
        "explicacao": "O comando 'wall' (write to all) envia uma mensagem para o terminal de todos os usuários que estão logados no sistema."
      },
      {
        "id": 4,
        "pergunta": "Qual dos seguintes comandos restaura apenas os arquivos que contêm 'lpi' em seu nome do arquivo <code>lpifiles.tar.gz</code>?",
        "opcoes": {
          "A": "<code>tar xvzf lpifiles.tar.gz --wildcards '*lpi*'</code>",
          "B": "<code>tar xvzwf lpifiles.tar.gz '*lpi*'</code>",
          "C": "<code>tar -xvfz lpifiles.tar.gz --deep '*lpi*'</code>",
          "D": "<code>tar -xvzf lpifiles.tar.gz --subdirs '*lpi*'</code>",
          "E": "<code>tar xvzf lpifiles.tar.gz --globbing '*lpi*'</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "A opção '--wildcards' no comando tar permite o uso de padrões (como curingas) para extrair seletivamente arquivos de um arquivo compactado. O padrão '*lpi*' corresponde a qualquer arquivo que contenha 'lpi' em seu nome."
      },
      {
        "id": 5,
        "pergunta": "Um usuário comum executou <code>./configure && make && make install</code>, mas a instalação falha. O que poderia ser feito para instalar o programa? (Escolha dois)",
        "opcoes": {
          "A": "Instalar os binários manualmente com <code>suinstall</code>",
          "B": "Executar <code>make install</code> com privilégios de root",
          "C": "Não executar <code>./configure</code> para manter a configuração padrão",
          "D": "Executar novamente <code>./configure</code> com a opção <code>--prefix</code> para um diretório onde o usuário tenha permissão de escrita",
          "E": "Executar <code>make install_local</code> para instalar em <code>/usr/local/</code>"
        },
        "respostaCorreta": ["B", "D"],
        "explicacao": "A falha geralmente ocorre por falta de permissão para escrever nos diretórios padrão do sistema. Executar 'make install' como root (com 'sudo') resolve isso. Alternativamente, usar '--prefix' no './configure' para um diretório pessoal permite a instalação sem privilégios de root."
      },
      {
        "id": 6,
        "pergunta": "O comando <code>cd /opt; tar xvf /dev/nst0;</code> foi executado com sucesso. O que acontecerá se a sequência de comandos for executada novamente?",
        "opcoes": {
          "A": "Um erro será gerado porque a fita foi ejetada",
          "B": "O conteúdo de <code>/opt</code> será restaurado novamente",
          "C": "O conteúdo de <code>/opt</code> será substituído pelo próximo arquivo na fita",
          "D": "Conteúdo adicional do próximo arquivo na fita será adicionado a <code>/opt</code>"
        },
        "respostaCorreta": "D",
        "explicacao": "O dispositivo /dev/nst0 é uma unidade de fita 'no-rewind' (sem rebobinar). Após a primeira extração, a fita para no final do arquivo. Executar o comando novamente continuará a leitura a partir daquele ponto, adicionando o conteúdo do próximo arquivo."
      },
      {
        "id": 7,
        "pergunta": "Qual comando descarta blocos não utilizados em um sistema de arquivos montado para dar suporte a dispositivos SSD?",
        "tipo": "fill",
        "respostaCorreta": "fstrim",
        "explicacao": "O comando 'fstrim' informa a um dispositivo de armazenamento (como um SSD) quais blocos de dados não estão mais em uso. Isso permite que o dispositivo otimize o desempenho e a longevidade."
      },
      {
        "id": 8,
        "pergunta": "Qual comando único simula um dispositivo com falha dentro de um array RAID 5?",
        "opcoes": {
          "A": "<code>mdadm --remove /dev/md0 /dev/sdd1</code>",
          "B": "<code>mdadm --zero-superblock /dev/sdf3</code>",
          "C": "<code>mdadm --force-fault /dev/md2 /dev/sde2</code>",
          "D": "<code>mdadm --fail /dev/md0 /dev/sdc1</code>",
          "E": "<code>mdadm /dev/md0 --offline /dev/sdc1</code>"
        },
        "respostaCorreta": "D",
        "explicacao": "O comando 'mdadm' com a opção '--fail' é usado especificamente para marcar um dispositivo dentro de um array RAID como defeituoso, o que é útil para testar a redundância."
      },
      {
        "id": 9,
        "pergunta": "Qual é o número mínimo de discos necessários em um array RAID 5 totalmente redundante?",
        "opcoes": {
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4",
          "E": "5"
        },
        "respostaCorreta": "C",
        "explicacao": "O RAID 5 requer um mínimo de três discos. Os dados e a paridade são distribuídos entre todos os discos, permitindo que o array sobreviva à falha de um único disco."
      },
      {
        "id": 10,
        "pergunta": "Um sistema tem um disco rígido e um gravador de CD, ambos conectados a controladores SATA. Qual dispositivo representa o gravador de CD?",
        "opcoes": {
          "A": "<code>/dev/hdb</code>",
          "B": "<code>/dev/sdd</code>",
          "C": "<code>/dev/scd1</code>",
          "D": "<code>/dev/sr0</code>",
          "E": "<code>/dev/sr1</code>"
        },
        "respostaCorreta": "D",
        "explicacao": "No Linux, dispositivos ópticos (CD/DVD) conectados via SATA são geralmente representados como /dev/srX. Discos rígidos são /dev/sdX. Dispositivos /dev/hdX são para a interface PATA/IDE mais antiga."
      },
      {
        "id": 11,
        "pergunta": "Qual ação deve ser executada após aumentar o tamanho de um volume lógico?",
        "opcoes": {
          "A": "Executar <code>vgresize</code>",
          "B": "Aumentar o tamanho do sistema de arquivos usado pelo volume lógico",
          "C": "Executar <code>lvresize</code>",
          "D": "Remontar o volume lógico"
        },
        "respostaCorreta": "B",
        "explicacao": "Aumentar o volume lógico (com lvextend/lvresize) apenas aloca mais espaço no nível do LVM. É necessário usar uma ferramenta como 'resize2fs' (para ext4) ou 'xfs_growfs' (para XFS) para que o sistema de arquivos expanda e utilize o novo espaço disponível."
      },
      {
        "id": 12,
        "pergunta": "Que informação é encontrada no trecho do arquivo <code>/proc/mdstat</code>? (Escolha duas)",
        "opcoes": {
          "A": "Um dos discos em /dev/md0 falhou e um disco sobressalente está sendo usado para recriar a redundância total",
          "B": "O disco sobressalente /dev/sda1 é usado para restaurar a redundância total após a recuperação atual",
          "C": "A informação [UU_] significa que o RAID está com um disco a menos e não está totalmente redundante",
          "D": "O dispositivo está usando metadados da versão 1.2 para permitir que LILO e GRUB Legacy usem /dev/md0 como partição de boot",
          "E": "A informação [3/2] significa que 3 discos RAID pertencem ao array e 2 discos são sobressalentes"
        },
        "respostaCorreta": ["A", "C"],
        "explicacao": "O status '[UU_]' indica um array de 3 discos onde o terceiro está ausente ou falhou. A linha 'recovery = 15.9%' mostra que o processo de reconstrução (recovery) está em andamento, implicando que um disco falhou e está sendo substituído/reconstruído."
      },
      {
        "id": 13,
        "pergunta": "Qual comando removerá um volume físico de um grupo de volumes?",
        "tipo": "fill",
        "respostaCorreta": "vgreduce",
        "explicacao": "O comando 'vgreduce' é usado para remover um ou mais volumes físicos (PVs) de um grupo de volumes (VG), após os dados terem sido movidos para fora dele."
      },
      {
        "id": 14,
        "pergunta": "Qual comando é usado para fazer uma cópia exata, em um único ponto no tempo, de um volume lógico, enquanto ainda permite que o volume lógico original seja atualizado?",
        "opcoes": {
          "A": "<code>lvclone</code>",
          "B": "<code>lvcreate</code>",
          "C": "<code>lvm2</code>",
          "D": "<code>lvsnap</code>",
          "E": "<code>lvsnapshot</code>"
        },
        "respostaCorreta": "B",
        "explicacao": "Para criar um snapshot LVM, usa-se o comando 'lvcreate' com a opção '-s' ou '--snapshot'. Um snapshot cria uma cópia 'point-in-time' de um volume lógico."
      },
      {
        "id": 15,
        "pergunta": "Qual dos seguintes comandos cria um subvolume Btrfs chamado 'volume' em <code>/mnt</code>?",
        "opcoes": {
          "A": "<code>btrfs subvolume add -n volume /mnt</code>",
          "B": "<code>btrfs create subvolume /mnt volume</code>",
          "C": "<code>btrfs-subvolume create /mnt/volume</code>",
          "D": "<code>btrfs subvolume new volume /mnt</code>",
          "E": "<code>btrfs subvolume create /mnt/volume</code>"
        },
        "respostaCorreta": "E",
        "explicacao": "A sintaxe correta para criar um subvolume Btrfs é 'btrfs subvolume create <caminho_do_subvolume>'. Neste caso, '/mnt/volume' é o caminho onde o novo subvolume será criado."
      },
      {
        "id": 16,
        "pergunta": "Qual palavra-chave está faltando na seguinte linha de <code>/etc/fstab</code> para conceder ao usuário 'fred' acesso de escrita aos arquivos no sistema de arquivos vfat?",
        "tipo": "fill",
        "respostaCorreta": "uid",
        "explicacao": "Sistemas de arquivos como VFAT não possuem permissões no estilo Unix. Para definir o proprietário dos arquivos, a opção de montagem 'uid' é usada, seguida pelo nome do usuário ou seu ID de usuário. Ex: 'uid=fred'."
      },
      {
        "id": 17,
        "pergunta": "Para inicializar 5 GB de espaço de swap adicional, qual combinação de comandos deve ser usada?",
        "opcoes": {
          "A": "<code>dd if=/dev/zero of=/tmp/swapfile bs=1024 count=5120000; mkswap /tmp/swapfile; mount /tmp/swapfile</code>",
          "B": "<code>dd if=/dev/zero of=/tmp/swapfile bs=1024 count=5120000; swapon /tmp/swapfile</code>",
          "C": "<code>dd if=/dev/zero of=/tmp/swapfile bs=1024 count=5120000; mkswap /tmp/swapfile; swapon /tmp/swapfile</code>",
          "D": "<code>touch -s 5G /tmp/swapfile; swapon /tmp/swapfile</code>",
          "E": "<code>mkswap /tmp/swapfile 512000; swapon /tmp/swapfile</code>"
        },
        "respostaCorreta": "C",
        "explicacao": "O processo correto é: 1) Criar um arquivo do tamanho desejado com 'dd'. 2) Formatar o arquivo como área de swap com 'mkswap'. 3) Ativar o arquivo de swap com 'swapon'."
      },
      {
        "id": 18,
        "pergunta": "Qual é o propósito de uma 'mount unit' do systemd?",
        "opcoes": {
          "A": "É usada pelo comando systemd-mount e permite aos usuários montar partições em pontos de montagem de sua escolha",
          "B": "É usada apenas para montar sistemas de arquivos de rede em pontos de montagem locais",
          "C": "É criada pelo comando systemd-fstab-generator para integrar as entradas de /etc/fstab no processo de inicialização do sistema",
          "D": "É usada pelo comando mount ao usar o systemd para montar e desmontar sistemas de arquivos"
        },
        "respostaCorreta": "A",
        "explicacao": "A pergunta se refere a uma 'system mount unit', que pode ser confusa. A resposta 'A' descreve a funcionalidade do comando `systemd-mount`, que permite a montagem por usuários. No entanto, a comunidade votou em 'C', que descreve como o systemd gerencia as montagens do /etc/fstab durante o boot, tratando-as como 'units'."
      },
      {
        "id": 19,
        "pergunta": "Qual comando garante que os sistemas de arquivos sejam escritos no disco após muitas operações de escrita?",
        "tipo": "fill",
        "respostaCorreta": "sync",
        "explicacao": "O comando 'sync' força a escrita imediata de todos os dados em buffer (no cache de memória) para o disco, sincronizando os sistemas de arquivos."
      },
      {
        "id": 20,
        "pergunta": "Qual componente de um sistema o <code>smartd</code> monitora?",
        "opcoes": {
          "A": "CPU",
          "B": "RAM",
          "C": "Discos rígidos",
          "D": "Tráfego Ethernet"
        },
        "respostaCorreta": "C",
        "explicacao": "O daemon 'smartd' faz parte do pacote smartmontools e é usado para monitorar a saúde de discos rígidos (HDDs e SSDs) usando a tecnologia S.M.A.R.T. (Self-Monitoring, Analysis, and Reporting Technology)."
      },
      {
        "id": 21,
        "pergunta": "Como o rótulo (label) 'root' pode ser adicionado ao sistema de arquivos ext4 em <code>/dev/sda1</code>?",
        "opcoes": {
          "A": "<code>relabel /dev/sda1 root</code>",
          "B": "<code>tune2fs -L root /dev/sda1</code>",
          "C": "<code>echo 'root' > /proc/fs/sda1/label</code>",
          "D": "<code>labelfs --device /dev/sda1 root</code>"
        },
        "respostaCorreta": "B",
        "explicacao": "O comando 'tune2fs' é usado para ajustar parâmetros em sistemas de arquivos ext2/ext3/ext4. A opção '-L' define o rótulo (label) do volume."
      },
      {
        "id": 22,
        "pergunta": "Qual subcomando do <code>cryptsetup</code> mostra informações sobre uma partição LUKS criptografada?",
        "opcoes": {
          "A": "<code>luksDump</code>",
          "B": "<code>luksInfo</code>",
          "C": "<code>luksDebug</code>",
          "D": "<code>luksLS</code>",
          "E": "<code>luksShow</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O comando 'cryptsetup luksDump /dev/partition' exibe informações detalhadas do cabeçalho de um dispositivo LUKS, como versão, cifras e slots de chave."
      },
      {
        "id": 23,
        "pergunta": "Qual dos seguintes é um padrão de sistema de arquivos para CD-ROM?",
        "opcoes": {
          "A": "OSI 9660",
          "B": "ISO 9660",
          "C": "SROFS",
          "D": "ISO 8859",
          "E": "ROM-EO"
        },
        "respostaCorreta": "B",
        "explicacao": "ISO 9660 é o padrão estabelecido pela Organização Internacional para Padronização (ISO) para sistemas de arquivos em mídias de CD-ROM."
      },
      {
        "id": 24,
        "pergunta": "Qual dos seguintes sistemas de inicialização vem com seu próprio carregador de inicialização UEFI?",
        "opcoes": {
          "A": "systemd",
          "B": "SysVinit",
          "C": "Upstart",
          "D": "OpenRC",
          "E": "launchd"
        },
        "respostaCorreta": "A",
        "explicacao": "O systemd inclui o 'systemd-boot' (anteriormente gummiboot), um gerenciador de boot UEFI simples para carregar kernels Linux e outros executáveis EFI."
      },
      {
        "id": 25,
        "pergunta": "Qual efeito a opção '-f' para o comando <code>update-rc.d</code> tem nos arquivos dos diretórios <code>/etc/rcX.d/</code> e <code>/etc/init.d/</code>?",
        "opcoes": {
          "A": "Forçará a remoção dos links simbólicos em <code>/etc/rcX.d/</code> mesmo quando os links são somente leitura",
          "B": "Removerá tanto os links simbólicos em <code>/etc/rcX.d/</code> quanto o script de inicialização em <code>/etc/init.d/</code>",
          "C": "Removerá o script de inicialização em <code>/etc/init.d/</code> e os links simbólicos em <code>/etc/rcX.d/</code> e atualizará as informações do pacote",
          "D": "Forçará a remoção dos links simbólicos em <code>/etc/rcX.d/</code> mesmo que o script de inicialização correspondente ainda exista em <code>/etc/init.d/</code>"
        },
        "respostaCorreta": "D",
        "explicacao": "A opção '-f' (force) para 'update-rc.d remove' força a remoção dos links simbólicos de runlevel, mesmo que o script original em /etc/init.d/ ainda esteja presente."
      },
      {
        "id": 26,
        "pergunta": "Qual comando é usado para instalar um carregador de boot GRUB no master boot record (MBR)?",
        "opcoes": {
          "A": "<code>grub-install</code>",
          "B": "<code>grub-mkconfig</code>",
          "C": "<code>grub-install-mbr</code>",
          "D": "<code>grub-glue-mbr</code>",
          "E": "<code>grub-mbr-setup</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O comando 'grub-install' (ex: 'grub-install /dev/sda') é a ferramenta padrão para instalar o bootloader GRUB no MBR de um dispositivo de armazenamento."
      },
      {
        "id": 27,
        "pergunta": "Se o arquivo que contém o kernel do Linux for deletado, o que acontece quando o sistema inicializa?",
        "opcoes": {
          "A": "O sistema inicia normalmente, pois o bootloader copia o kernel para o MBR",
          "B": "Em vez do kernel, o initramfs é carregado para reinstalar o kernel",
          "C": "O bootloader monta o sistema de arquivos raiz e inicia /bin/sh",
          "D": "Sem um kernel, o sistema não pode inicializar e, dependendo do bootloader, um erro é exibido"
        },
        "respostaCorreta": "D",
        "explicacao": "O kernel é o núcleo do sistema operacional. O bootloader (como o GRUB) é responsável por carregar o kernel na memória. Se o arquivo do kernel não for encontrado, o processo de boot falha e uma mensagem de erro é exibida."
      },
      {
        "id": 28,
        "pergunta": "Qual diretório contém arquivos de 'unit' do systemd específicos do sistema? (Especifique o caminho completo)",
        "tipo": "fill",
        "respostaCorreta": "/lib/systemd/system",
        "explicacao": "O diretório /lib/systemd/system contém os arquivos de 'unit' padrão fornecidos pelos pacotes de software instalados. Modificações locais e novas units devem ser colocadas em /etc/systemd/system."
      },
      {
        "id": 29,
        "pergunta": "Um servidor Linux com systemd inicializou no modo de resgate (rescue.target). Quais comandos são usados para restaurar o servidor ao seu alvo usual? (Escolha dois)",
        "opcoes": {
          "A": "<code>telinit 0</code>",
          "B": "<code>systemctl default</code>",
          "C": "<code>sync</code>",
          "D": "<code>systemctl emergency</code>",
          "E": "<code>systemctl reboot</code>"
        },
        "respostaCorreta": ["B", "E"],
        "explicacao": "A resposta correta no PDF é AB, mas 'telinit 0' desliga o sistema. A comunidade votou BE. 'systemctl default' tenta mudar para o target padrão (geralmente graphical.target). 'systemctl reboot' reinicia o sistema, que então iniciará no target padrão. Ambas as abordagens (B ou E) são formas válidas de sair do modo de resgate."
      },
      {
        "id": 30,
        "pergunta": "Qual é o principal arquivo de configuração para o processo de inicialização SystemV? (Especifique o nome completo do arquivo, incluindo o caminho)",
        "tipo": "fill",
        "respostaCorreta": "/etc/inittab",
        "explicacao": "No antigo sistema de inicialização SysVinit, o arquivo /etc/inittab era o principal arquivo de configuração que definia o runlevel padrão e o que fazer em cada runlevel."
      },
      {
        "id": 31,
        "pergunta": "Qual é o propósito de um <code>initramfs</code> durante o início do sistema Linux?",
        "opcoes": {
          "A": "Ele carrega os módulos necessários e inicia subsistemas como o LVM para tornar o sistema de arquivos raiz acessível ao kernel",
          "B": "Ele move o kernel da memória normal para a memória initram para acelerar o acesso ao kernel",
          "C": "Ele copia o conteúdo do sistema de arquivos raiz para a RAM para acelerar o sistema",
          "D": "Ele cria um disco RAM para armazenar dados voláteis para diretórios como /tmp"
        },
        "respostaCorreta": "A",
        "explicacao": "O initramfs (Initial RAM File System) é um pequeno sistema de arquivos carregado na memória. Seu principal objetivo é conter os drivers e ferramentas (como para RAID, LVM, ou LUKS) necessários para montar o sistema de arquivos raiz real, que o kernel por si só pode não conseguir acessar."
      },
      {
        "id": 32,
        "pergunta": "Qual dos seguintes é um aplicativo de espaço de usuário usado para modificar entradas EFI em um sistema Linux?",
        "opcoes": {
          "A": "<code>efieditor</code>",
          "B": "<code>configefi</code>",
          "C": "<code>efimanager</code>",
          "D": "<code>efibootmgr</code>",
          "E": "<code>efibootedit</code>"
        },
        "respostaCorreta": "D",
        "explicacao": "O utilitário 'efibootmgr' é usado para interagir com o firmware UEFI. Ele pode listar, criar, modificar e excluir entradas de boot, bem como alterar a ordem de inicialização."
      },
      {
        "id": 33,
        "pergunta": "Em qual árvore de diretórios os arquivos são modificados ao alterar parâmetros do kernel usando o comando <code>sysctl</code>?",
        "opcoes": {
          "A": "<code>/sys/kernel/</code>",
          "B": "<code>/proc/kernel/</code>",
          "C": "<code>/proc/sys/</code>",
          "D": "<code>/lib/sys/</code>",
          "E": "<code>/sys/proc/</code>"
        },
        "respostaCorreta": "C",
        "explicacao": "O comando 'sysctl' é uma interface para modificar os parâmetros do kernel em tempo de execução. Esses parâmetros são expostos como arquivos virtuais no diretório /proc/sys/."
      },
      {
        "id": 34,
        "pergunta": "Qual é o propósito do comando <code>udevadm monitor</code>?",
        "opcoes": {
          "A": "Ele escuta eventos do kernel produzidos por uma regra udev e imprime informações no console",
          "B": "Ele monitora o diretório /dev/ para novos dispositivos",
          "C": "Ele monitora o processo udev e imprime estatísticas de desempenho",
          "D": "Ele se comunica com o D-Bus para configurar novos dispositivos"
        },
        "respostaCorreta": "A",
        "explicacao": "'udevadm monitor' é uma ferramenta de depuração que escuta os eventos do kernel (uevents) e os eventos enviados pelo udev após o processamento das regras, mostrando em tempo real o que está acontecendo durante a detecção de dispositivos."
      },
      {
        "id": 35,
        "pergunta": "Como o código-fonte dos principais módulos do kernel Linux é distribuído?",
        "opcoes": {
          "A": "Está incluído no código-fonte do kernel Linux",
          "B": "Os módulos do kernel são baixados sob demanda conforme são usados durante a compilação",
          "C": "Os módulos do kernel têm seu próprio ciclo de lançamento e podem ser mantidos separadamente do código-fonte do kernel Linux",
          "D": "É fornecido como um download separado junto com o código-fonte do kernel Linux para a mesma versão"
        },
        "respostaCorreta": "A",
        "explicacao": "Os módulos que fazem parte da árvore principal do kernel (in-tree) são distribuídos junto com o código-fonte do próprio kernel. Eles são compilados ao mesmo tempo que o kernel."
      },
      {
        "id": 36,
        "pergunta": "Após baixar o <code>patch-4.6.4.xz</code>, quais são os próximos passos para preparar a compilação de um kernel Linux versão 4.6.4? (Escolha dois)",
        "opcoes": {
          "A": "Descompactar o arquivo e mover o diretório resultante para <code>/usr/src/linux</code>",
          "B": "Aplicar o arquivo de patch ao diretório fonte do kernel contendo a versão 4.6.0",
          "C": "Aplicar o arquivo de patch ao diretório fonte do kernel contendo a versão 4.6.3",
          "D": "Descompactar o arquivo usando <code>xz</code> para obter o arquivo de patch descompactado",
          "E": "Usar o <code>patch</code> para aplicar o arquivo de patch descompactado ao diretório fonte de qualquer versão anterior do kernel"
        },
        "respostaCorreta": ["B", "D"],
        "explicacao": "A comunidade votou em BD. Um arquivo .xz é um arquivo compactado, então primeiro ele precisa ser descompactado com 'xz -d'. Um patch como 'patch-4.6.4' é incremental e geralmente se aplica à versão anterior mais próxima (4.6.3), mas a opção B menciona a versão base (4.6.0). O correto seria aplicar o patch na versão imediatamente anterior. A resposta do gabarito é DE, o que é incorreto, pois um patch é específico, não para 'qualquer versão'."
      },
      {
        "id": 37,
        "pergunta": "Após compilar e instalar manually um novo kernel, o que deve ser feito em relação ao <code>initramfs</code>?",
        "opcoes": {
          "A": "O <code>initramfs</code> é independente do kernel e não deve ser modificado",
          "B": "Como o <code>initramfs</code> contém módulos do kernel, um novo <code>initramfs</code> deve ser construído para o novo kernel",
          "C": "Durante a compilação do kernel, um novo <code>initramfs</code> é construído automaticamente. Ele só precisa ser instalado",
          "D": "O sistema deve ser reiniciado, pois o <code>initramfs</code> se reconfigura para o novo kernel durante a inicialização"
        },
        "respostaCorreta": "C",
        "explicacao": "A resposta do gabarito é C, mas a comunidade votou em B. Na prática, B é mais preciso. O initramfs contém módulos específicos da versão do kernel. Após instalar um novo kernel, você deve gerar um novo initramfs (usando ferramentas como 'mkinitcpio' ou 'dracut') para que ele inclua os módulos corretos para o novo kernel."
      },
      {
        "id": 38,
        "pergunta": "Qual dos seguintes comandos exibe o caminho físico do módulo do kernel chamado 'dummy'?",
        "opcoes": {
          "A": "<code>modprobe -i dummy</code>",
          "B": "<code>modinfo -n dummy</code>",
          "C": "<code>modpath -v dummy</code>",
          "D": "<code>depmod -n dummy</code>",
          "E": "<code>modshow -p dummy</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "A resposta do gabarito é A, mas a comunidade votou em B. A opção correta é 'modinfo -n dummy' (ou --filename), que é projetada especificamente para mostrar o caminho do arquivo do módulo. 'modprobe -i' (ou --ignore-install) é para instalar um módulo ignorando comandos."
      },
      {
        "id": 39,
        "pergunta": "Qual dos seguintes parâmetros instrui o kernel, no momento do boot, a usar apenas um dos processadores disponíveis?",
        "opcoes": {
          "A": "<code>maxcpus=1</code>",
          "B": "<code>usecpus:=1</code>",
          "C": "<code>smpcpus=1</code>",
          "D": "<code>vcpumx=1</code>",
          "E": "<code>vmxcpus=1</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O parâmetro de boot 'maxcpus=N' informa ao kernel para usar no máximo N núcleos de CPU, mesmo que mais estejam disponíveis fisicamente. Definir 'maxcpus=1' limita o sistema a um único núcleo."
      },
      {
        "id": 40,
        "pergunta": "Após a instalação de um kernel auto-compilado, os módulos que precisam ser carregados não são encontrados. Qual 'make target' provavelmente foi esquecido durante a instalação?",
        "tipo": "fill",
        "respostaCorreta": "modules_install",
        "explicacao": "O processo de compilação do kernel é separado da instalação dos módulos. Após compilar o kernel, o comando 'make modules_install' deve ser executado para copiar os módulos compilados para o diretório apropriado (geralmente /lib/modules/<versão-do-kernel>/)."
      },
      {
        "id": 41,
        "pergunta": "Em um servidor executando o kernel Linux 3.4.50-11, qual arquivo no diretório <code>/boot</code> contém os parâmetros de configuração do kernel?",
        "opcoes": {
          "A": "<code>config-linux-3.4.50-11</code>",
          "B": "<code>config-3.4.50-11</code>",
          "C": "<code>system-3.4.50-11</code>",
          "D": "<code>vmlinuz-3.4.50-11</code>",
          "E": "<code>rc.config-3.4.50-11</code>"
        },
        "respostaCorreta": "B",
        "explicacao": "Muitas distribuições Linux armazenam o arquivo de configuração (.config) usado para compilar um kernel específico no diretório /boot com o nome 'config-<versão-do-kernel>'. Isso permite a referência futura de quais opções foram habilitadas."
      },
      {
        "id": 42,
        "pergunta": "Qual dos seguintes comandos, por padrão, fornece os PIDs dos processos ordenados por quais estão usando mais ciclos de CPU?",
        "opcoes": {
          "A": "<code>top</code>",
          "B": "<code>uptime</code>",
          "C": "<code>ps aux</code>",
          "D": "<code>vmstat</code>",
          "E": "<code>freemem</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O comando 'top' exibe uma visão dinâmica e em tempo real dos processos do sistema. Por padrão, a lista é ordenada pela porcentagem de uso da CPU em ordem decrescente."
      },
      {
        "id": 43,
        "pergunta": "Na saída do comando <code>sar -b</code>, o que significa 'tps'?",
        "opcoes": {
          "A": "Terabyte por segundo",
          "B": "Tráfego por segundo",
          "C": "Transferências por segundo",
          "D": "Dados totais por segundo",
          "E": "Terabit por segundo"
        },
        "respostaCorreta": "C",
        "explicacao": "Na saída do 'sar -b' (estatísticas de I/O), a coluna 'tps' representa o número total de transferências por segundo que foram emitidas para os dispositivos físicos."
      },
      {
        "id": 44,
        "pergunta": "Na seguinte saída do comando <code>uptime</code>, as médias de carga representam as médias de carga do sistema para quais períodos de tempo? '... load average: 0.47, 24.71, 35.31'",
        "opcoes": {
          "A": "1, 5 e 15 minutos",
          "B": "1, 15 e 30 minutos",
          "C": "5, 20 e 25 segundos",
          "D": "15, 30 e 60 minutos",
          "E": "15, 45 e 90 segundos"
        },
        "respostaCorreta": "A",
        "explicacao": "A média de carga (load average) em sistemas Unix/Linux é tradicionalmente exibida para os últimos 1, 5 e 15 minutos, respectivamente."
      },
      {
        "id": 45,
        "pergunta": "Quais das seguintes propriedades devem ser registradas para monitorar a qualidade de um link de rede? (Escolha duas)",
        "opcoes": {
          "A": "Largura de banda em ambas as direções",
          "B": "Número de nós usando o link",
          "C": "Latência efetiva",
          "D": "Número de pacotes IPv4 e IPv6",
          "E": "Número de portas TCP usadas"
        },
        "respostaCorreta": ["A", "C"],
        "explicacao": "A qualidade de um link de rede é primariamente medida por sua largura de banda (throughput) e sua latência (delay). Perda de pacotes e jitter também são métricas importantes."
      },
      {
        "id": 46,
        "pergunta": "Qual comando relata informações sobre uso de memória, paginação e entrada/saída de bloco?",
        "opcoes": {
          "A": "<code>free</code>",
          "B": "<code>memshow</code>",
          "C": "<code>lsof</code>",
          "D": "<code>pidof</code>",
          "E": "<code>vmstat</code>"
        },
        "respostaCorreta": "E",
        "explicacao": "O comando 'vmstat' (virtual memory statistics) fornece um relatório abrangente sobre processos, memória, paginação (swap in/out), I/O de bloco, traps e atividade da CPU."
      },
      {
        "id": 47,
        "pergunta": "Para coletar dados de desempenho com <code>sar</code> por um longo período de tempo, qual comando deve ser executado periodicamente a partir do cron?",
        "opcoes": {
          "A": "<code>sa1</code>",
          "B": "<code>sarmon</code>",
          "C": "<code>sarec</code>",
          "D": "<code>sadf</code>",
          "E": "<code>sarcron</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O utilitário 'sa1' é projetado para ser executado pelo cron. Ele coleta e armazena os contadores do sistema em um arquivo de dados binário diário, que pode ser analisado posteriormente pelo comando 'sar'."
      },
      {
        "id": 48,
        "pergunta": "Quais comandos abaixo são úteis para coletar dados sobre conexões de sistemas de arquivos remotos? (Escolha dois)",
        "opcoes": {
          "A": "<code>pidstat</code>",
          "B": "<code>nfsiostat</code>",
          "C": "<code>sadf</code>",
          "D": "<code>cifsiostat</code>",
          "E": "<code>fsiostat</code>"
        },
        "respostaCorreta": ["B", "D"],
        "explicacao": "'nfsiostat' exibe estatísticas para sistemas de arquivos montados via NFS. 'cifsiostat' exibe estatísticas para sistemas de arquivos montados via CIFS/SMB."
      },
      {
        "id": 49,
        "pergunta": "Um servidor web com 64GB de RAM e duas partições de swap de 64GB cada tem um aumento de uso de RAM de 65% para 75% com um aumento de 20% nos usuários. O swap quase não é usado. Qual seria a reação apropriada? (Escolha duas)",
        "opcoes": {
          "A": "Atrasar qualquer upgrade de hardware até que haja um consumo significativo de swap",
          "B": "Criar um dispositivo RAID 1 nas duas partições de swap",
          "C": "Considerar a instalação de um servidor de aplicação adicional para distribuir a carga",
          "D": "Mover os scripts e o conteúdo da aplicação web para um disco RAM",
          "E": "Atualizar o hardware para aumentar a quantidade de RAM disponível para evitar o uso de swap"
        },
        "respostaCorreta": ["C", "E"],
        "explicacao": "Com o uso de RAM já em 75% e projetado para crescer, o sistema está se aproximando da saturação de memória. Adicionar mais RAM (E) é uma solução direta para evitar o uso de swap (que é lento). Distribuir a carga para outro servidor (C) é uma estratégia de escalabilidade horizontal para lidar com o aumento de usuários."
      },
      {
        "id": 50,
        "pergunta": "Quais dos seguintes arquivos de configuração são usados pelo <code>tcpwrapper</code>?",
        "opcoes": {
          "A": "<code>/etc/tcpd.allow</code> e <code>/etc/tcpd.deny</code>",
          "B": "<code>/etc/tcpwrapper.allow</code> e <code>/etc/tcpwrapper.deny</code>",
          "C": "<code>/etc/hosts.allow</code> e <code>/etc/hosts.deny</code>",
          "D": "<code>/etc/access.allow</code> e <code>/etc/access.deny</code>",
          "E": "<code>/etc/service.allow</code> e <code>/etc/service.deny</code>"
        },
        "respostaCorreta": "C",
        "explicacao": "O TCP Wrapper, uma ferramenta de controle de acesso à rede baseada em host, usa os arquivos /etc/hosts.allow e /etc/hosts.deny para definir quais hosts têm permissão ou são negados para acessar serviços de rede."
      },
      {
        "id": 51,
        "pergunta": "Qual programa lista informações sobre arquivos e conexões de rede abertos por processos?",
        "tipo": "fill",
        "respostaCorreta": "lsof",
        "explicacao": "O comando 'lsof' (LiSt Open Files) é usado para listar todos os arquivos abertos e os processos que os abriram. Isso inclui arquivos regulares, diretórios, sockets de rede, pipes, etc."
      },
      {
        "id": 52,
        "pergunta": "Um cliente de rede tem uma interface <code>eth0</code> com um IP na sub-rede 192.168.0.0/24. O roteador é 192.168.0.1. Qual comando pode ser usado para habilitar o roteador como gateway padrão? (Escolha dois)",
        "opcoes": {
          "A": "<code>route add default gw 192.168.0.1 eth0</code>",
          "B": "<code>ifconfig eth0 defaultroute 192.168.0.1</code>",
          "C": "<code>ip route add default via 192.168.0.1</code>",
          "D": "<code>echo 'defaultroute 192.168.0.1' >> /etc/resolv.conf</code>",
          "E": "<code>route add defaultgw=192.168.0.1 if=eth0</code>"
        },
        "respostaCorreta": ["A", "C"],
        "explicacao": "'route add default gw ...' é a sintaxe do antigo pacote 'net-tools'. 'ip route add default via ...' é a sintaxe do pacote moderno 'iproute2'. Ambos os comandos adicionam uma rota padrão à tabela de roteamento."
      },
      {
        "id": 53,
        "pergunta": "Qual comando mostra o tempo levado para resolver uma consulta DNS?",
        "tipo": "fill",
        "respostaCorreta": "dig",
        "explicacao": "O comando 'dig' (Domain Information Groper) é uma ferramenta poderosa para consultas DNS. Sua saída inclui uma seção que mostra o 'Query time', indicando quanto tempo a consulta levou para ser concluída."
      },
      {
        "id": 54,
        "pergunta": "Quais das palavras-chave de filtro abaixo poderiam ser usadas no comando <code>tcpdump -i eth0 ...</code>? (Escolha três)",
        "opcoes": {
          "A": "<code>host</code>",
          "B": "<code>ip</code>",
          "C": "<code>src</code>",
          "D": "<code>dst</code>",
          "E": "<code>ipv6</code>"
        },
        "respostaCorreta": ["A", "C", "D"],
        "explicacao": "O tcpdump usa uma linguagem de filtro rica. 'host' filtra pelo endereço IP de origem ou destino. 'src' e 'dst' são qualificadores que especificam se o endereço é a fonte (source) ou o destino (destination) do tráfego. 'ip' e 'ipv6' são usados para filtrar por protocolo, mas 'src' e 'dst' são qualificadores mais comuns."
      },
      {
        "id": 55,
        "pergunta": "Qual dos seguintes comandos adiciona um endereço IPv6 estático à interface de rede <code>eth0</code>?",
        "opcoes": {
          "A": "<code>ip add addr 2001:db8::1337/64 dev eth0</code>",
          "B": "<code>ip -6 add addr 2001:db8::1337/64 dev eth0</code>",
          "C": "<code>ip addr add 2001:db8::1337/64 dev eth0</code>",
          "D": "<code>ip -6 addr add new 2001:db8::1337/64 dev eth0</code>",
          "E": "<code>ip addr add -6 2001:db8::1337/64 dev eth0</code>"
        },
        "respostaCorreta": "C",
        "explicacao": "A resposta do gabarito é D, mas a comunidade votou C, que é a sintaxe correta e mais comum. O comando 'ip addr add <endereço>/<prefixo> dev <interface>' é usado para adicionar endereços IPv4 e IPv6. O comando 'ip' é inteligente o suficiente para reconhecer o formato do endereço IPv6."
      },
      {
        "id": 56,
        "pergunta": "Em um nó Linux com múltiplas interfaces de rede ativas, cada uma com uma rota padrão para a Internet, qual rota padrão é preferida?",
        "opcoes": {
          "A": "A rota padrão com o maior valor de métrica",
          "B": "A rota padrão com o maior valor de MTU",
          "C": "A rota padrão com o menor valor de TTL",
          "D": "A rota padrão com o maior valor de TTL",
          "E": "A rota padrão com o menor valor de métrica"
        },
        "respostaCorreta": "E",
        "explicacao": "A métrica de uma rota é um valor que indica o 'custo' de usar essa rota. Quando múltiplas rotas para o mesmo destino existem, o sistema sempre prefere a rota com o menor valor de métrica."
      },
      {
        "id": 57,
        "pergunta": "Com base no trecho da saída do tcpdump '... 192.168.5.112.21 > 192.168.123.5.1065 ...', qual serviço ou protocolo de rede foi usado?",
        "opcoes": {
          "A": "FTP",
          "B": "HTTP",
          "C": "SSH",
          "D": "DNS",
          "E": "DHCP"
        },
        "respostaCorreta": "A",
        "explicacao": "A saída mostra a comunicação de e para a porta 21 (indicada por '.21' após o endereço IP). A porta 21 é a porta padrão bem conhecida para o serviço FTP (File Transfer Protocol)."
      },
      {
        "id": 58,
        "pergunta": "O que deve ser feito para garantir que uma máquina cliente use o nameserver recursivo em execução no endereço IP 192.168.0.1? (Escolha dois)",
        "opcoes": {
          "A": "Adicionar 'nameserver 192.168.0.1' a <code>/etc/resolv.conf</code>",
          "B": "Executar <code>route add nameserver 192.168.0.1</code>",
          "C": "Executar <code>ifconfig eth0 nameserver 192.168.0.1</code>",
          "D": "Garantir que 'dns' esteja listado na entrada 'hosts' no arquivo <code>/etc/nsswitch.conf</code>",
          "E": "Executar <code>bind add nameserver 192.168.0.1</code>"
        },
        "respostaCorreta": ["A", "D"],
        "explicacao": "O arquivo '/etc/resolv.conf' é onde os endereços IP dos servidores DNS são configurados. O arquivo '/etc/nsswitch.conf' define a ordem de consulta para resolução de nomes; a entrada 'hosts' deve incluir 'dns' para que o sistema consulte os servidores DNS."
      },
      {
        "id": 59,
        "pergunta": "Qual dos seguintes comandos mostra as capacidades e frequências utilizáveis para a interface sem fio <code>wlan0</code>?",
        "opcoes": {
          "A": "<code>iw phy phy0 info</code>",
          "B": "<code>iw dev wlan0 info</code>",
          "C": "<code>iw dev wlan0 show</code>",
          "D": "<code>iw phy wlan0 show</code>",
          "E": "<code>iw phy0 show</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O comando 'iw phy <nome_phy>' mostra as capacidades do dispositivo físico (hardware). Cada dispositivo físico (phy0, phy1) pode ter uma ou mais interfaces virtuais (wlan0, wlan1). Para ver as capacidades de hardware como frequências e modos suportados, você deve consultar o dispositivo 'phy'."
      },
      {
        "id": 60,
        "pergunta": "Qual dos seguintes comandos lista endereços IPv4 e endereços MAC de nós de rede que o sistema local viu em suas redes IP diretamente conectadas?",
        "opcoes": {
          "A": "<code>arp</code>",
          "B": "<code>ifconfig</code>",
          "C": "<code>ipadm</code>",
          "D": "<code>iwlist</code>"
        },
        "respostaCorreta": "A",
        "explicacao": "O comando 'arp' exibe e manipula o cache ARP (Address Resolution Protocol) do sistema. Este cache mapeia endereços IP para seus endereços MAC correspondentes na rede local."
      }
    ];

    const quizContainer = document.getElementById('quiz-container');
    let currentQuestionIndex = 0;
    let answerLog = new Array(quizData.length).fill(null);

    function renderQuiz() {
        const currentQuestion = quizData[currentQuestionIndex];
        let optionsHTML = '';

        if (currentQuestion.tipo === 'fill') {
            const savedAnswer = answerLog[currentQuestionIndex] || '';
            optionsHTML = `<input type="text" id="fill-answer" class="option" placeholder="Digite sua resposta..." value="${savedAnswer}">`;
        } else if (currentQuestion.opcoes) { // CORREÇÃO: Garante que 'opcoes' existe antes de tentar lê-lo
            for (const key in currentQuestion.opcoes) {
                const isSelected = answerLog[currentQuestionIndex] && answerLog[currentQuestionIndex].includes(key) ? 'selected' : '';
                optionsHTML += `<div class="option ${isSelected}" data-key="${key}"><strong>${key}.</strong>&nbsp; ${currentQuestion.opcoes[key]}</div>`;
            }
        }

        const nextButtonText = (currentQuestionIndex === quizData.length - 1) ? 'Finalizar Quiz' : 'Responder e Próxima';

        quizContainer.innerHTML = `
            <div id="question-counter">Questão ${currentQuestionIndex + 1} de ${quizData.length}</div>
            <h2 id="question">${currentQuestion.pergunta}</h2>
            <div id="options-container">${optionsHTML}</div>
            <div id="controls">
                <button id="prev-btn">Anterior</button>
                <button id="next-btn">${nextButtonText}</button>
            </div>
        `;
        
        addEventListeners();
        updateUIState();
    }

    function addEventListeners() {
        document.getElementById('prev-btn').addEventListener('click', navigatePrev);
        document.getElementById('next-btn').addEventListener('click', logAnswerAndAdvance);

        const currentQuestion = quizData[currentQuestionIndex];
        const fillAnswerInput = document.getElementById('fill-answer');
        
        if (fillAnswerInput) {
            fillAnswerInput.focus(); // MELHORIA: Foco automático no campo de texto
            fillAnswerInput.addEventListener('input', (event) => {
                answerLog[currentQuestionIndex] = event.target.value.trim() || null;
                updateUIState();
            });
            // MELHORIA: Permite submeter com a tecla "Enter"
            fillAnswerInput.addEventListener('keyup', (event) => {
                if (event.key === 'Enter' && !document.getElementById('next-btn').disabled) {
                    logAnswerAndAdvance();
                }
            });
        } else {
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', () => {
                    selectOption(option, option.dataset.key, Array.isArray(currentQuestion.respostaCorreta));
                });
            });
        }
    }

    function updateUIState() {
        document.getElementById('prev-btn').disabled = currentQuestionIndex === 0;
        const isAnswered = !!answerLog[currentQuestionIndex];
        document.getElementById('next-btn').disabled = !isAnswered;
    }

    function selectOption(optionDiv, key, isMultipleChoice) {
        if (isMultipleChoice) {
            optionDiv.classList.toggle('selected');
        } else {
            document.querySelectorAll('.option.selected').forEach(el => el.classList.remove('selected'));
            optionDiv.classList.add('selected');
        }
        
        let selectedKeys = [];
        document.querySelectorAll('.option.selected').forEach(el => selectedKeys.push(el.dataset.key));
        answerLog[currentQuestionIndex] = selectedKeys.length > 0 ? selectedKeys : null;
        
        updateUIState();
    }

    function logAnswerAndAdvance() {
        if (currentQuestionIndex < quizData.length - 1) {
            currentQuestionIndex++;
            renderQuiz();
        } else {
            showFinalReport();
        }
    }

    function navigatePrev() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            renderQuiz();
        }
    }

    function showFinalReport() {
        let correctAnswers = 0;
        let detailedReviewHTML = '';

        quizData.forEach((question, index) => {
            const userAnswer = answerLog[index];
            const correctAnswer = Array.isArray(question.respostaCorreta) ? question.respostaCorreta : [question.respostaCorreta];
            
            const sortedUserAnswer = Array.isArray(userAnswer) ? [...userAnswer].sort() : [userAnswer];
            const sortedCorrectAnswer = [...correctAnswer].sort();
            
            let isCorrect = false;
            if (question.tipo === 'fill') {
                isCorrect = userAnswer && (userAnswer.toLowerCase() === correctAnswer[0].toLowerCase());
            } else {
                isCorrect = JSON.stringify(sortedUserAnswer) === JSON.stringify(sortedCorrectAnswer);
            }

            if (isCorrect) correctAnswers++;

            let userAnswerText;
            if (!userAnswer) {
                userAnswerText = '<em>Não respondida</em>';
            } else if (Array.isArray(userAnswer)) {
                userAnswerText = userAnswer.join(', ');
            } else {
                userAnswerText = userAnswer; 
            }
            
            const correctAnswerText = correctAnswer.join(', ');
            const resultClass = isCorrect ? 'resposta-certa' : 'resposta-errada';

            detailedReviewHTML += `
                <div class="review-item">
                    <h4>${index + 1}. ${question.pergunta}</h4>
                    <p class="resposta-usuario ${resultClass}">Sua resposta: ${userAnswerText}</p>
                    ${!isCorrect ? `<p class="resposta-correta-final">Resposta correta: ${correctAnswerText}</p>` : ''}
                    <p class="explicacao">${question.explicacao}</p>
                </div>
            `;
        });

        const totalQuestions = quizData.length;
        const incorrectAnswers = totalQuestions - correctAnswers;
        const correctPercentage = ((correctAnswers / totalQuestions) * 100).toFixed(1);
        const incorrectPercentage = ((incorrectAnswers / totalQuestions) * 100).toFixed(1);
        const finalGrade = ((correctAnswers / totalQuestions) * 10).toFixed(1);

        quizContainer.innerHTML = `
            <div id="final-report">
                <h2>Relatório Final</h2>
                <p>Confira o seu desempenho detalhado abaixo:</p>
                <div id="report-details">
                    <div class="report-item report-item-acertos"><strong>${correctAnswers}</strong><span>Acertos (${correctPercentage}%)</span></div>
                    <div class="report-item report-item-erros"><strong>${incorrectAnswers}</strong><span>Erros (${incorrectPercentage}%)</span></div>
                    <div class="report-item report-item-nota" style="grid-column: 1 / -1;"><strong>${finalGrade} / 10.0</strong><span>Nota Final</span></div>
                </div>
                <div id="detailed-review">
                    <h3>Revisão das Questões</h3>
                    ${detailedReviewHTML}
                </div>
                <div id="controls" style="justify-content: center; margin-top: 30px;">
                    <button onclick="location.reload()">Reiniciar Quiz</button>
                </div>
            </div>
        `;
    }

    renderQuiz();
</script>

</body>
</html>